# 聊天程序

在这次作业中, 你将需要写一个简单的程序通过网络连接用户：一个聊天服务器.  该程序类似 [Slack](https://www.slack.com) 或者 [IRC](https://tools.ietf.org/html/rfc1459), 你完成后的聊天服务器将能支持用户在不同群组中聊天. 用户可以创建并且加入群组，一旦一个用户加入某个群组中，那么他发送的消息通过群组的其他用户将会收到此消息。

此次作业(包括后面的所有作业)将用Python 2实现. 这次作业将会让你熟悉socket api编程

#### 一些要点

- 项目的基础代码可以在 [这里找到](https://github.com/jenenliu/cs168fall17_student/tree/master/projects/proj1_chat). 你可以自己下载或者用git clone下来.
- 你最后完成的时候应该只有两个文件: 一个是 `client.py`, 另外一个是 `server.py`. 无需修改 `utils.py`. 

#### 参考资源

- 往期做过次项目的一些演示视频在[这里可以看到](https://youtu.be/4btZs--wlpI).
- 如果你有任何疑问，可以先参考 [FAQ 部分](#faq).  如果问题还未解决，找你哥.
- [Python Socket 编程指南](https://docs.python.org/2/howto/sockets.html) 是一个很好的Python2 socket编程教程，你应该读一下.
- 我们准备了两个文件给你测试你的代码:
  - `client_split_messages.py` 能帮助并确保你的服务器能正常缓存消息, 详细描述在文档后面.
  - `simple_test.py` 通过模拟创建两个用户在一个群组里聊天来测试你的程序.  `simple_test.py` 只是通过客户端聊天的输出来测试你的代码是否正常工作，并且只能测试到一小部分.

##  什么是 sockets?

socket表示的是两个程序通过网络连接时它们所连接的点.  每个socket都会和某个特定的端口绑定在一起.  Socket 是操作系统提供的一层抽象: 程序创建了socket, 从这些socket里面读取信息, 并且向这些socket里面写入信息.  当一个程序向socket里面写入信息时, 操作系统将会通过该socket绑定的端口发送信息出去; 同样的, 当操作系统从某个端口接收到信息时, 这些信息将会被绑定该端口的socket所读取.

在Python里, 你可以通过[socket 标准库](https://docs.python.org/2/library/socket.html) 来创建socket并且连接到一个远程端口, 代码如下:

    import socket
    # socket构造函数会接收几个参数; 在这里使用默认参数即可.
    client_socket = socket.socket()
    client_socket.connect(("1.2.3.4", 5678))
    client_socket.sendall("Hello World")
    
这个例子中我们创建了一个socket并且连接到端口5678而IP地址是1.2.3.4的机器. 然后，它发送了一个"Hello World"消息到服务器 1.2.3.4:5678.

上面的例子创建了一个socket客户端并且只连接到一个远程机器.  而当你创建一个服务器时, 你将能同时接收多个客户端连接, 并且你创建客户端的socket时并不需要知道他们的地址.  所以，socket服务器的代码将会不太一样:

    server_socket = socket.socket()
    server_socket.bind(("1.2.3.4", 5678))
    server_socket.listen(5)
    
当你创建socket后, 相比于连接到某个特定的远程机器, 上面的代码 *绑定* 了socket在某个特定的IP地址和端口上, 此时便相当于告诉操作系统把这个socket绑定在对应的IP地址和端口上.  最后,  `listen` 会监听所有连接到此IP地址和端口的socket.  当有新的客户端连接到此socket时, python的socket标准库将会创建一个新的socket和此客户端保持连接和通信, 所以服务器的socket才能继续监听端口并等待其他新的客户端连接上来:

    (new_socket, address) = server_socket.accept()
    
这个函数将会一个堵塞直到有个新的客户端连接上来 (通过使用 `connect()` 函数, 就像上面的例子所展示的), 并且返回一个新创建的socket, `new_socket`, 这个socket可以从来和客户端发送并且接收该客户端的消息.  比如，下面的代码

    message = new_socket.recv(1024)
    
将会堵塞知道有新的消息从客户端那里接收过来, 并且将会返回最多1024字节的信息.

你将需要阅读一下Python socket教程来理解一下这些api的含义.  __特别需要注意的是，比如举个例子, 使用 `send` 和 `recv`! `send` 不需要发送所有传给它的数据.__  [Python Socket 编程教程](https://docs.python.org/2/howto/sockets.html) 是个很好的socket学习资源.

## 第一部分 

作业的第一部分将会帮助你开始使用socket编程api并且介绍一下最基本的客户端-服务端交互.  

在这一部分的作业中, 你需要写一个简单的客户端和服务器. 客户端将会从标准输入读取然后发送消息到服务器然后断开连接.  服务器需要输出所接收到的消息到标准输出.  如果有多个客户端连接到服务器, 服务器应当能排队处理 (比如, 它应当输出收到的当前客户端发过来的所有消息然后关闭客户端连接，然后接着处理下一个连接).

服务器程序应该接受一个命令行参数, 用来表示服务器使用的端口:

    $ python basic_server.py 12345
    
客户端应当接收两个参数: 一个是要连接的服务器的主机名字 (或者IP地址) 以及服务器的端口:

    $ python basic_client.py localhost 12345
    
你的服务器应当能被所有和你主机有网络连接的机器连接上 (具体看 FAQ).

### 阻塞型socket

在这部分的作业中, 使用阻塞型socket是没问题的.  "阻塞" 表示的是一个socket可能会停住一段时间, 直至整个函数处理完成.  socket调用完会被阻塞的情况包括:

- `send`: 如果socket所使用的缓冲区满了没法继续写入  (这是发送函数)
- `recv`: 如果socket所使用的缓冲区是空的没有东西可以读取 (比如, 如果客户端突然停止发送了)  (这是接收函数)
- `accept`: 如果此时没有客户端连接上来  (这是接收客户端连接的函数)

### 一些使用例子

你写好的客户端和服务器应当和下面的演示例子一样.  假设有两个客户端分别连上服务器:

    $ python basic_client.py localhost 12345
    I am a student in CS168. This class is awesome!
    $ python basic_client.py localhost 12345
    Why is Shenker so bad at drawing?
    
如果服务器在客户端连接上来之前已经在12345端口启动了, 它应当有如下输出:

    $ python basic_server.py 12345
    I am a student in CS168. This class is awesome!
    Why is Shenker so bad at drawing?
 

## 第二部分

在接下来的作业中, 你将需要在你上面所写的代码基础上写一个支持多用户多群组聊天的服务器. 这里的 [演示视频](https://youtu.be/4btZs--wlpI)可以
告诉你你的程序应当长什么样子

### 服务器功能

服务器程序应该接受一个命令行参数，改参数表示服务器绑定在哪个端口上.

#### 消息

和你在第一部分的服务器不同, 这部分作业的服务器需要支持多个用户同时在线并且可以同时互发消息.  每个客户端应当有个对应的名字 (这样每个客户端才能知道他们在给谁发送消息) 并且需要知道该客户端在哪个群组里面. 当客户端第一次连上来时，不会有对应的名字和群组.  服务器接收到的第一个客户端的消息将作为客户端的名字.

服务器从客户端接收的消息分为两种类型.  第一种类型的消息为命令控制消息; 命令控制消息始终以"/"开头.  有几种不同的控制消息需要服务器处理:

- `/join <channel>` 命令应当添加发送该命令的客户端到此群组中. 客户端每次只能在一个群组中, 所以如果一个客户端已经加入了一个群组, 这个命令将会把客户端从该群组中移除. 当一个客户端加入某个群组时, 应当有一条消息广播给群里的每个人告诉他们此客户端加入群组.  同样的，当一个客户端离开群组时, 一条此客户端退出群组的消息应当广播给群组里的每个人.
- `/create <channel>` 命令应当创建一个群组, 并且添加此客户端到该群组.  就像 `/join` 命令一样, 此时客户端应当从他已加入的群组中移除.
- `/list` 命令应当发送一条消息给客户端当前已有的所有群组, 每个群组用换行符隔开.

第二种类型的消息就是普通的群里聊天消息.  所有不是以 `/` 开头的消息都当做普通消息.  每次发送出去的消息应当广播给群组里的其他所有人, 消息开头应该是发消息的客户端的名字，用中括号括起来 (参考下面例子).  消息 _不应当_ 从一个群组发送到另外一个群组. 如果客户端不在某个群组里面，客户端发送消息时，服务器应该回复一个错误提醒消息.

当一个客户端断开连接时, 一个客户端下线的消息应当广播给群里所有的人.

##### 消息划界

Socket提供了数据流功能, 但是它们不会区分不同的消息. 当 `recv` 函数调用后并返回数据时, socket不会告诉你接收到的数据是一条消息, 还是几条消息, 或者只是一部分消息. 所以你需要一个检测消息是否结束的方法. 对这个作业来说, 我们使用定长(200字节)来表示一个消息 (包括服务器发送到客户端的消息也是). 如果一个消息长度小于200字节, 则你需要在消息后面加上空格填充上 (而接收者在接收到消息后应当把最后面不需要的空格过滤掉). 你可以假设所有发送的消息都不会超过200个字节.

请确保你的代码能正确的处理一些小于200字节的消息 (此时 `recv` 会返回小于200字节的数据) 并且能够处理当有多条消息存在缓存里的情况. 你应当能够通过缓存来处理不完整的消息: 如果一个 `recv` 函数只返回一部分消息, 你的代码应当能够保存这些数据并且等待另一部分消息到来, 然后处理一整条消息. 比如, 如果一个客户端从服务器接收到150个字节, 你的代码应当保存这150个字节并且等待另外50个字节发送过来. 客户端应当在收到一整个消息也就是200个字节的时候才将消息输出到标准输出中.  为了帮助你检查你的服务器能否处理这种情况, 我们提供了一个特别的客户端 (`client_split_messages.py`) 此客户端会在发送消息到服务器之前切割一整条消息. 注意这个客户端只检查了一小部分服务器应当处理的场景! 你应该修改这个客户端代码来测试更多的场景.

#### 错误处理

你的服务器应当能处理一些客户端乱发消息的情况，当客户端乱发消息时回复错误消息给客户端. 比如, 如果客户端发送了 `/join` 但却没有发送它想加入的群组名字, 服务器此时应当回复客户端一个错误消息. 我们提供的 `utils.py` 包括了所有你应当处理的错误场景的错误消息. 你可以通过Python的格式化语句来格式化错误消息. 举个例子, `utils.py` 定义了一下错误消息:

    CLIENT_SERVER_DISCONNECTED = "Server at {0}:{1} has disconnected"
    
此时你可以使用 `.format` 函数来格式化使用IP地址和端口号来替换上面的 `{0}` 和 `{1}`:

    error_message = CLIENT_SERVER_DISCONNECTED.format("localhost", 12345)

__你必须使用定义在 `utils.py` 中的错误信息常量. 如果你没有使用 `utils.py` 中的错误信息常量, 错误信息处理部分将没有分数.__

当一个客户端发送的命令导致了某些错误, 则此命令不应当对服务器有任何的改变. 举个例子, 如果一个客户端此时在 `cs168_tas` 群里并且向加入一个不存在的群组, 则服务器 __不应当__ 将客户端从 `cs168_tas` 群组中移除.

我们只会测试包括在 `utils.py` 中的错误类型. 你应当自己考虑更多的场景并且自己测试这些场景.

### 客户端功能

每个客户端会连接到一个特定的服务器, 并且会有对应的名字.  你的客户端应该按照下面的命令行启动:

    $ python client.py Scott 127.0.0.1 55555
    
这个命令应当让客户端连接到对应的IP地址和端口的服务器中, 并且发送Scott这条消息给服务器来从而来设置自己的名字.

当客户端成功启动后, 客户端应当同时监听来自服务器和标准输入的消息.  服务器发送过来的消息应当输出在终端上 (记得去掉加在最后面的多余的空格)而从标准输入过来的消息应当发送到服务器 (在添加了必要的空格只有).  客户端应当在发送每个消息前输出[Me]用来区分自己发出去的消息和接收到的别人的消息.  当一个客户端从服务器接收到消息时, 新的消息应当输出在 `[Me]` 消息后面. 具体的例子可以看一下上面的示例视频.

以下是一个客户端连接到本地55555端口的服务器的一个交互示例:

	python client.py Panda localhost 55555
	[Me] Hello world!
	Not currently in any channel. Must join a channel before sending messages.  // 意思是：当前不在任何频道，必须加入某个频道才能发送消息
	[Me] /list
	[Me] /create 168_tas
	[Me] /list
	168_tas
	[Me] Hello world!
	Alice has joined
	[Alice] Hi everyone! Does anyone know what we're doing on the first day of lecture?
	
当看到Alice的消息以后, Panda 关闭了它的客户端. 当Panda创建了168_tas频道以后, 启动了另一个客户端:

	python client.py Alice 127.0.0.1 55555
	[Me] /list
	168_tas
	[Me] /join 168_tas
	[Me] Hi everyone! Does anyone know what we're doing on the first day of lecture?
	Panda has left

### 细节

我们已经提供了 `utils.py` 定义了所有你应当使用的错误消息. 这些只是为了让你代码写起来方便一点, 并且能让我们做一些测试. 请确保你使用了这些错误消息; 否则, 你的代码将不会通过测试!

### 非阻塞型socket

这部分的作业你将需要使用非阻塞socket, 因为你的客户端和服务器都需要从不同的地方接收信息, 并且消息顺序也是不确定的. 想象一下如果想第一部分一样使用阻塞socket的话以下的调用场景会发生什么, 我们像如下代码一样调用客户端接收消息:

    message_from_server = client_socket.recv(200)
    
现在假设服务器有一小段时间都没有发送消息, 但是当客户端调用了 `recv` 来等待服务器的消息并返回时, 用户输入了几个字符到标准输入中. 此时客户端应当读取标准输入并且发送消息到服务器 -- 但是此时客户端只能阻塞卡死在那里等待服务器发送消息过来! 我们可以用非阻塞socket来解决这个问题.

如果想要使用非阻塞socket, 你需要调用 `select` 库里面的 `select` 函数. 更多的关于如何使用 `select` 以及一些例子, 可以参考一下 [这个网页](http://www.bogotobogo.com/python/python_network_programming_tcp_server_client_chat_server_chat_client_select.php).  当你在使用非阻塞socket来接收新的连接和数据时, 可以使用阻塞函数来发送消息 (因为这里你需要发送的信息很短并且短时间内不需要发送大量的消息, 此时 `send` 和 `sendall` 应当不会阻塞较长时间).

## FAQ

##### 我可以使用什么Python库?

我们的工程代码import了select, socket, 和 sys. 所以你应当不需要再import其他库

##### 我怎么才能知道我要连的服务器的地址信息?

如果你在本地启动你的服务器, 则你的客户端可以使用 "localhost" 或者 127.0.0.1 来连接. 它们是用来表示本地连接的特殊的名字/地址. 如果你想连接到另外的机器，则localhost 和 127.0.0.1就没法作为连接的地址, 因为如果另外一个机器也用这个地址, 它们也指的是对于自己本地机器的程序开放. 如果你想连接到另外的机器, 你需要知道该机器对外开放的IP地址. 有些网站可以查得到 (比如, Google "What's my IP address"), 或者你可以通过 `ifconfig` 名利来查看.  `ifconfig` 将会列出所有的网络口信息; 比如:

    $ ifconfig
    lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384
	options=3<RXCSUM,TXCSUM>
		inet6 ::1 prefixlen 128 
		inet 127.0.0.1 netmask 0xff000000 
		inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 
		nd6 options=1<PERFORMNUD>
	en0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
		ether 78:31:c1:c0:a7:44 
		inet6 fe80::7a31:c1ff:fec0:a744%en0 prefixlen 64 scopeid 0x4 
		inet 172.19.131.124 netmask 0xffffff00 broadcast 172.19.131.255
		nd6 options=1<PERFORMNUD>
		media: autoselect
		status: active
	en1: flags=963<UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX> mtu 1500
		options=60<TSO4,TSO6>
		ether 72:00:02:3f:79:50 
		media: autoselect <full-duplex>
		status: inactive
		
上面所列的第一部分是回环地址, 此地址只能用来给机器内部的程序访问. 你会注意到这个网口的IP地址(写在 `inet`后面)一直都是 `127.0.0.1`.  看一下另外一个IP地址和回环地址不一样的网口 -- 可以发现, 有个对外IP地址是 `127.19.131.124` (也就是在 `en0` 那一列的信息).

如果你的网口是在 [NAT](http://en.wikipedia.org/wiki/Network_address_translation) 后面, 其他机器将无法访问你的服务器地址. 本学期的后面我们将会学习NAT. 此项目完成时，你可以通过不同的机器连接上你的服务器进行聊天, 可以试着在WiFi下连接你的客户端, 此时不会使用NAT, 保证了每个客户端有唯一的IP地址.

##### 用什么样的端口给服务器比较好?

很多小的端口都被系统使用了; 尽量使用大于1000的端口号.

##### 当我启动我的服务器时，收到这样的错误消息 `Address already in use`

这个错误信息表示有其他程序正在使用你想使用的端口. 有时候这种情况会暂时出现 -- 比如, 如果你的服务器因为一些错误意外退出了, 此时服务器所使用的所有socket还没有被操作系统全部清除掉的时候.  所以当这种消息出现时，可以试着使用另外一个端口.

##### 当我调用 `listen` 函数的时候应该使用多大的连接数来给它做参数?

对于此次作业来讲，5就够了

##### 使用定长消息显得很笨重而且会造成内存浪费. 有其他解决办法吗?

对于这次作业来说，你必须使用定长消息. 如果你对于实际程序中的处理办法很感兴趣，这里有两种解决办法. 第一种是在消息与消息之间设置分隔符 (比如, 可以利用一些不可能在消息中出现的字符串来分隔不同的消息, 比如像 `:==`) 此时就可以利用它来确定一个消息是否结束.  第二种 (也是更常用的) 的解决办法就是在数据的第一个位置写入数据的大小.

##### 当我从服务器接收到新的消息的时候, 怎样才能在终端上输出新的消息，覆盖过 "[Me]", 使它在我的上一行?

你可以在输出的时候，给你的消息前面加个 "\r" 字符.  只是有个需要注意的是当你从服务器收到的字符长度小于 "[Me]" 字符串的时候. 比如, 当客户端发送了 `/list` 命令到服务器, 然后其中有个群组名字叫 "A". 输出将会是像下面这样子的:

    [Me] /list
    A

但是如果你不注意的话，输出可能会变成下面这个样子:

    [Me] /list
    AMe]
    
你可以使用 `utils.CLIENT_WIPE_ME` 来解决这个问题 (需要注意的是如果你使用了这个常量, 你将需要把 "\r" 放在下一行字符串的前面，以避免输出多余的空格).

##### 我需要自己关闭服务器socket吗?

不需要. 如果你的服务器代码是在 `while True:` 循环了里面的话, 就像第一部分的服务器代码一样.

##### 当服务器断开的时候，客户端需要退出吗?

是的，并且客户端需要打印在 `utils.py` 中的关于服务器断开的错误信息.

##### 我是用的饿是Windows然后发现select不起作用?.
  
不幸的是, 因为文件描述符的实现方式不一样，在Windows中标准输入并不会被当做一个socket. 所有的测试都会在Linux系统下进行, 所以如果你的代码是在Windows的文件描述符下面实现的，那么会造成不必要的错误. 

### 感谢

此次作业的灵感来自于普林斯顿大学的计算机网络课程的 [socket编程作业](HTTP://www.cs.princeton.edu/courses/archive/spr15/cos461/assignments/0-sockets.html). 
